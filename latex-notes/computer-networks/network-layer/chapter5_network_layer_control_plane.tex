\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, positioning}

\geometry{margin=1in}
\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=cyan}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textbf{\TOPICTITLE}}
\fancyhead[R]{\thepage}

% ------------------------------- 
% Topic Metadata
% ------------------------------- 
\newcommand{\TOPICTITLE}{Network Layer}
\title{\TOPICTITLE\\\large Study-Ready Notes}
\author{Compiled by Andrew Photinakis}
\date{\today}

\setlength{\headheight}{15pt}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section*{Chapter 5: The Network Layer — Control Plane}

\section{5.1 Introduction}

\section{5.2 Routing Algorithms}

\subsection{Concept Overview}

\begin{enumerate}
    \item Logic of how packets forwarded is done in control plane, implemented by routing algorithms
    \item A good path is synonymous with "least-cost", such path populates forwarding table in each router
\end{enumerate}


\subsection{Graph Abstraction: Modeling the Network}
\begin{enumerate}
    \item Assume graph G = (N , E)
    \item N = nodes in graph that represent routers in network, are points where packet-forwarding decisions are made
    \item E = edges, represent physical links that connect routers
    \item Costs c(x, y) = each edge (x, y) is assigned a numerical cost
          \begin{enumerate}
              \item Cost is typically set by network admin, is a piece of policy
              \item 3 types of costs
                    \begin{enumerate}
                        \item Physical distance, a trans-oceanic link has a higher cost than a short link
                        \item Link speed, a 1 Gbps link might have a cost of 10, while a 100 Gbps link has a cost of 1. Often inversely proportional to bandwidth
                        \item Monetary cost, leasing a link from another provider may be more "costly"
                    \end{enumerate}
          \end{enumerate}
\end{enumerate}

\subsection{Taxonomy of Routing Algorithms}
\begin{enumerate}
    \item Centralized
          \begin{enumerate}
              \item Algo computes least-cost path using complete, global knowledge of network
              \item Has complete map of all nodes and all edge costs
              \item Can be done at a single site (like an SDN controller) or replicated on every router, butkey is that the input is the global network state
              \item Approach is known as a Link-State algorithm
          \end{enumerate}
    \item Decentralized
          \begin{enumerate}
              \item Calculation distributed among routers
              \item Each node begins with only local knowldge (cost of its own directly attached links)
              \item Iterative process of communication only with neighbors, a node gradually learns least-cost paths to other nodes
              \item Approach know as Distance-Vector algorithm
          \end{enumerate}
    \item Static vs Dynamic
          \begin{enumerate}
              \item Static: routes are changed very slowly, often by human admin manually editing costs or forwarding tables
              \item Dynamic: routes cahnge automatically as network topology or link costs change.
          \end{enumerate}
    \item Load-Sensitive vs Load-Insentive
          \begin{enumerate}
              \item Load-Sensitive: link costs dynamically change to reflect current level of congestion on link. Idea to route around congestion
              \item Load-Insensitive: link costs are fixed and do not reflect current load
          \end{enumerate}
\end{enumerate}

\subsection{5.2.1 Link State Routing Algorithm}

\begin{enumerate}
    \item Centralized approach that uses complete, global knowledge of network and lnk costs to compute least-cost paths
    \item Each node in network responsible for a simple task
          \begin{enumerate}
              \item Discover neighbors and link costs
              \item Broadcast this info to all other nodes in network
              \item Receive link-state packets from all other nodes and build a complete, identical map of entire network
              \item Compute least-cost paths from itself to all other nodes using map
          \end{enumerate}
    \item Dijkstras Algorithm
          \begin{enumerate}
              \item Iterative algo, finds least-cost paths in increasing order of cost
              \item After k-th iteration, algo has found least-cost path to kndoes that are closest to source
              \item Sicne each router computes its own table independently based on received global info, a malfunctioning router can only broadcast an incorrect cost for its attached links, and cannot directly corrupt entire network's routing knowledge
              \item Variables
                    \begin{enumerate}
                        \item N: set of nodes to which least-cost path is definitively known
                        \item D(u): current cost of least-cost path from source (u) to node v. value updated as new, shorter paths found
                        \item p(u): predecessor node neighbor of v along current least-cost path from source. Used to build forwarding table
                    \end{enumerate}
                    \begin{verbatim}
                        // Initialization
                    1.  N' = {u}  // The source node is the only member
                    2.  for all nodes v
                    3.      if v is a neighbor of u
                    4.          then D(v) = c(u,v)
                    5.          else D(v) = infinity
                    6.
                    // Loop
                    7.  loop
                    8.      find w not in N' such that D(w) is a minimum
                    9.      add w to N'
                    10.     update D(v) for each neighbor v of w and not in N':
                    11.         // Does the path through w to v offer a shorter cost?
                    12.         D(v) = min( D(v), D(w) + c(w,v) )
                    13.         // If D(v) was updated, set p(v) = w
                    14. until N' = N
                    \end{verbatim}
              \item Pathological Oscillations
                    \begin{enumerate}
                        \item Problem arises if link costs are load-sensitive, that is if cost of a link depends on amount of traffic it is carrying
                        \item Cost of link equals traffic it carries
                        \item Solution is to not use load sensitive costs and ensure routers don't run algorithm at same time. Done by randomizing when link state updates are sent or when algorithm is run
                    \end{enumerate}
          \end{enumerate}
\end{enumerate}

\subsection{5.2.2 Distance Vector Routing Algorithm}

\begin{enumerate}
    \item Distance vector algorithm is decentralized approach
    \item Code is it "tell your neighbors what you know about the world"
    \item Algorithm is:
          \begin{enumerate}
              \item Distributed, each node communicates only with direct neighbors
              \item Iterative, process repreats until no more information is exchanged and calcualtions stabilized
              \item Async, nodes don't need to operate in lock step
              \item Self-Terminating, algorithm stops when calculations converge
          \end{enumerate}
    \item In DV, a node knows cost to its neighbors, and receives it "distance vectors" from its neighbors. A distance vector is a list of cost estimates from that neighbor to all other nodes in network
\end{enumerate}

\subsubsection{Bellman-Ford Algorithm}

\begin{enumerate}
    \item \textbf{Definitions of variables:}
          \begin{itemize}
              \item $d_x(y)$: Node $x$'s estimate of the least-cost path from $x$ to destination $y$.
              \item $c(x,v)$: The cost of the direct link from node $x$ to neighbor $v$.
              \item $N(x)$: The set of neighbors of node $x$.
              \item $d_v(y)$: Node $v$'s estimate of the least-cost path from $v$ to destination $y$.
          \end{itemize}

    \item \textbf{Bellman--Ford update formula:}
          \[
              d_x(y)
              =
              \min_{v \in N(x)} \left\{ c(x,v) + d_v(y) \right\}
          \]

          \begin{itemize}
              \item Node $x$ considers every neighbor $v \in N(x)$.
              \item For each neighbor, it computes:
                    \[
                        c(x,v) + d_v(y)
                    \]
              \item It chooses the neighbor $v$ that yields the smallest total cost.
          \end{itemize}

    \item \textbf{Intuition:}
          The cost from node $x$ to destination $y$ is the minimum, over all neighbors $v$, of the cost to reach $v$ plus the cost (as advertised by $v$) for $v$ to reach $y$.

    \item \textbf{Distance Vector at each node:}
          Each node $x$ maintains a distance vector
          \[
              D_x = \big[ D_x(y) : y \in \mathcal{N} \big]
          \]
          representing its current estimates of $d_x(y)$ for all destinations $y$.

    \item \textbf{Update behavior:}
          When node $x$ receives a distance vector $D_v$ from neighbor $v$, it recomputes its own distance vector using the Bellman--Ford formula.
          If any entry changes, node $x$ sends its updated distance vector $D_x$ to all neighbors.

    \item \textbf{Distance Vector Algorithm (Pseudo-Code):}

          \begin{verbatim}
At each node x:

1. Initialization:
2.     for all destinations y in N:
3.         D_x(y) = c(x,y)       // If y not a direct neighbor: c(x,y) = infinity
4.     for each neighbor w:
5.         send distance vector D_x to w

6. loop
7.     wait until a distance vector D_v is received from neighbor v

8.     for each destination y in N:
9.         // Bellman-Ford update
10.        D_x(y) = min over all neighbors u { c(x,u) + D_u(y) }

11.    if any D_x(y) changed:
12.        send updated distance vector D_x to all neighbors

13. forever
\end{verbatim}

    \item Pathological Dynamics
          \begin{enumerate}
              \item Complexity of DV is when link costs change
              \item Cases to consider:
                    \begin{enumerate}
                        \item Link cost decreases
                        \item Link cost increases at \& count to infinity problem
                    \end{enumerate}
              \item Solution
                    \begin{enumerate}
                        \item Poisoned Reverse
                        \item A simple fix for 2-node loops
                              \begin{enumerate}
                                  \item if z routes to x through y, z will "lie" to y and advertise its distance to x to inifinity
                              \end{enumerate}
                        \item
                    \end{enumerate}
          \end{enumerate}
\end{enumerate}


\subsubsection{Comparison of Link-State vs Distance-Vector Algorithms}
\begin{table}[h!]
    \centering
    \begin{tabular}{|p{3.5cm}|p{5.5cm}|p{5.5cm}|}
        \hline
        \textbf{Feature}                                                                                                                 & \textbf{Link-State (LS) Algorithm} & \textbf{Distance-Vector (DV) Algorithm} \\ \hline

        Information Shared                                                                                                               &
        Each node broadcasts the cost of its directly attached links to all other nodes (flooding).                                      &
        Each node sends its distance vector (its current cost estimates to all destinations) only to its immediate neighbors.                                                                                           \\ \hline

        Knowledge                                                                                                                        &
        \textbf{Global}: Every node builds a complete map of the network topology.                                                       &
        \textbf{Local}: A node knows only its neighbors and the information received from them.                                                                                                                         \\ \hline

        Message Complexity                                                                                                               &
        High. Each link-state update is flooded across the entire network: typically $O(N\,E)$ messages.                                 &
        Lower. Only neighbor-to-neighbor exchanges; typically $O(N^2)$ over time depending on convergence.                                                                                                              \\ \hline

        Speed of Convergence                                                                                                             &
        Fast. Once link-state information propagates, each node runs Dijkstra in $O(N^2)$ or $O(N \log N)$. No loops during convergence. &
        Slower. Can suffer from routing loops and the \textit{count-to-infinity} problem.                                                                                                                               \\ \hline

        Robustness                                                                                                                       &
        High. A node computes its own routes independently; a faulty node can only report incorrect local link costs.                    &
        Lower. Incorrect distance vectors can propagate from one node to another and corrupt the entire network state.                                                                                                  \\ \hline

        Used By                                                                                                                          &
        OSPF, IS-IS                                                                                                                      &
        RIP, BGP (path vector variant)                                                                                                                                                                                  \\ \hline
    \end{tabular}
\end{table}

\subsubsection{5.2 Section-Wide Summary}

\textbf{Key Terms and Definitions}

\begin{itemize}
    \item \textbf{Routing Algorithm}: The control-plane process for finding ``good'' (least-cost) paths through a network of routers.
    \item \textbf{Graph} ($G = (N, E)$): Abstract model of a network where nodes $N$ are routers and edges $E$ are links with associated costs.
    \item \textbf{Least-Cost Path}: The path between two nodes with the minimum sum of edge costs.
    \item \textbf{Centralized Algorithm}: Requires complete, global network state (a full map) as input.
    \item \textbf{Decentralized Algorithm}: Nodes compute paths iteratively using only local information from neighbors.
    \item \textbf{Link-State (LS) Algorithm}: Canonical centralized approach (e.g., Dijkstra’s). Each node floods its local link information to all others.
    \item \textbf{Dijkstra’s Algorithm}: Greedy, iterative algorithm used in LS to compute shortest paths from a source to all other nodes.
    \item \textbf{Distance-Vector (DV) Algorithm}: Canonical decentralized approach (e.g., Bellman–Ford). Each node sends its distance vector to its neighbors.
    \item \textbf{Bellman–Ford Equation}:
          \[
              d_x(y) = \min_{v \in N(x)} \{ c(x,v) + d_v(y) \}
          \]
    \item \textbf{Count-to-Infinity}: A pathological DV behavior where a link cost increase causes slow propagation of “bad news,” leading to routing loops and repeatedly increasing distance estimates.
    \item \textbf{Poisoned Reverse}: A mitigation for 2-node loops in DV; a node advertises an infinite distance to a destination through the neighbor it routes through.
\end{itemize}

\textbf{Core Relationships}

\begin{itemize}
    \item Routing algorithms compute the paths that populate the forwarding tables in the data plane.
    \item Centralized algorithms correspond to LS (e.g., Dijkstra’s).
    \item Decentralized algorithms correspond to DV (e.g., Bellman–Ford).
    \item The Bellman–Ford equation defines shortest paths recursively; DV implements this recursively and distributively.
    \item Count-to-Infinity is the major weakness of DV and results from slow propagation of link-cost increases.
\end{itemize}

\textbf{Key Insights and Takeaways}

\begin{itemize}
    \item All routing algorithms model the network as a graph and attempt to solve the least-cost path problem.
    \item \textbf{Fundamental tradeoff:}
          \begin{itemize}
              \item LS (centralized): robust, fast convergence, but high message overhead (flooding).
              \item DV (decentralized): low message overhead (neighbor-only), but slow convergence and vulnerable to loops.
          \end{itemize}
    \item Pathological behaviors matter:
          \begin{itemize}
              \item LS can oscillate when link costs depend on load.
              \item DV can count to infinity when link costs increase.
          \end{itemize}
    \item The Internet uses both approaches:
          \begin{itemize}
              \item OSPF $\rightarrow$ LS
              \item BGP $\rightarrow$ DV-like (path vector)
          \end{itemize}
    \item No single algorithm is universally superior—both excel in different contexts.
\end{itemize}



\section{5.3 Intra-AS Routing in the Internet: OSPF}

\subsection{Need for Routing Hierarchy: Scale and Autonomy}

A "flat" network where every router runs same algorithm doesn't work for global internet for 2 reasons

\begin{enumerate}
    \item Scale
          \begin{enumerate}
              \item Storage and Computation
                    \begin{enumerate}
                        \item Internet has hundreds of millions of routers
                        \item A link-state algorithm like Dijkstra's, which requires each router to store a map of the entire network and run an $O(N^2)$ or $O(N \log N)$ computation, is completely unfeasible at this scale.
                    \end{enumerate}
              \item COmmunication Overhead
                    \begin{enumerate}
                        \item a link-state algo requires link-state 'advertisements' (LSAs) to be flooded to every other router
                        \item Communication overheard would be overwhelming.
                        \item Distance vector would never converge
                    \end{enumerate}
          \end{enumerate}
    \item Administrative Autonomy
          \begin{enumerate}
              \item Internet is not one network, it's composed of thousands of individual ISPs, universities, and corporate networks
              \item An ISP is its own administrative domain. It wants and needs to run its network as it sees fit. SHould be able to choose its own internal routing algo and manage its network for its own performance and economic goals.
              \item Furthermore, an ISP has no desire to "broadcast" details of its internal network topology and link costs to its competitors
          \end{enumerate}
\end{enumerate}

\subsection{Solution: Autonomous Systems (ASs)}

\begin{enumerate}
    \item Is a group of routers that are all under same admin control, typically a single ISP or a large organization
    \item Each AS identified by a globally unique Autonomous System Number (ASN), which is assigned by ICANN regional registries
    \item Two-level hierarchy
          \begin{enumerate}
              \item Intra-AS Routing (Interior Gateway Protocol - IGP)
                    \begin{enumerate}
                        \item Routing algorithm that runs within a single AS
                        \item ALl routes in AS are teammates and run samw intra-AS protocol
                        \item Focus is on performance, finding best path within network
                    \end{enumerate}
              \item Inter-AS Routing (Exterior Gateway Protocol - EGP)
                    \begin{enumerate}
                        \item routing algorithm that runs between ASs
                        \item Protocol is used to route traffic across different ISPs
                        \item Focus is on policy, enforcing economic and security rules (e.g. "I will not carry traffic from this competitor for free")
                    \end{enumerate}
          \end{enumerate}
\end{enumerate}

\subsection{OSPF: Canonical Intra-AS Protocol}

\begin{enumerate}
    \item Open Shortest Path First
    \item is a link-state protocol that uses Dijkstras algo to compute shortest paths
    \item How it works
          \begin{enumerate}
              \item Construct map: each router in AS constructs a complete, identical topological map of entire AS
              \item Flood Information: To build map, each router broadcasts its link-state information (i.e. its list of directly connected neighbors and costs of those links) to all other routers in AS.
              \item Run Dijkstras: Once router has complete map, it runs Dijkstras alg using itself as root node. Finds least-cost path from itself to every other node (and subnet) in AS
              \item Install Routes: router uses results of Dijkstras to build forwarding table
          \end{enumerate}
    \item Practical View: Link Costs
          \begin{enumerate}
              \item Cost of a link is not standard, its a configured parameter set by network admin
              \item OSPF provides mechanism to find least-cost path, but policy of what "cost" means is up to admin
          \end{enumerate}
\end{enumerate}

\subsection{OSPF Link-State Broadcasts}

Detail of OSPF is how it manages its link-state advertisements (LSAs)

\begin{enumerate}
    \item Transport: messages are not sent over TCP or UDP, sent directly inside IP datagrams, using IP protocol number 89
    \item Implication: Doesn't use a transport protocol, must implement its own reliability. Checks that links are operational (using HELLO messages sent to neighbors), and allows routers to get a neighbors link-state database
    \item When to broadcast
          \begin{enumerate}
              \item On Change: A router broadcasts its link-state information whenever one of its links changes state (e.g. goes down, comes up, or its cost is unchanged)
              \item Periodically: for robustness, router also re-broadcasts its link state at a regular interval even if there has been no change
          \end{enumerate}
\end{enumerate}

\subsection{Advanced Features in OSPFv2}

is not just a simple implementation of Dijkstras. [RFC 2328] specifies several advances features that are critical in real-world networks

\begin{enumerate}
    \item Security
          \begin{enumerate}
              \item How do you stop a malicious router from joining AS and injecting false link-state advertisements?
              \item OSPF allows for authenticaion of OSPF messages
                    \begin{enumerate}
                        \item Simple Auth: clear-text password, which is weak
                        \item MD5 Auth
                              \begin{enumerate}
                                  \item All routers configured with a shared secret key
                                  \item Router computes an MD5 hash of OSPF packet (including key) and sends hash with packet
                                  \item Receiver does same computation and verifies hash
                                  \item Provides message integrity and authentication, and sequence numbers are used to prevent replay attacks
                              \end{enumerate}
                    \end{enumerate}
          \end{enumerate}
    \item Multiple Same-Cost Paths
          \begin{enumerate}
              \item What if Dijkstra's finds two paths to a destination with exact same cost?
              \item Instead of just picking one, OSPF allows router to install both paths in its forwarding table
              \item Traffic destined for that node can then be split across both paths
              \item Simple and effective form of load balancing
          \end{enumerate}
    \item Support for Hierarchy (Areas)
          \begin{enumerate}
              \item For a very large AS, flooding LSAs to every touer is too much overhead
              \item Solution: AS can be partitioned into areas
              \item Inra-Area routing: routers within an area run their own OSPF algorithm. THey flood LSAs only to other routers in same area. Each router in area has a complete map of only its area
              \item Backbone area (Area 0): One special area is designated as backbone. Primary role of backbone is to route traffic between different areas
              \item Area Border Routers (ABRs): Routers that sit at edge of an area. They're in backbone and in one or more other areas. Summarize routing information from their area and advertise it to the backbone, and vice-versa
          \end{enumerate}
    \item Multicast support: OSPF extended by Multicast OSPF (MOSPF), which uses same link-state database and flooding mechanism to compute multicast paths
\end{enumerate}


\subsection{Section-Wide Summary}

\textbf{Key Terms and Definitions}

\begin{itemize}
    \item \textbf{Autonomous System (AS):} A group of routers under a single administrative control.
    \item \textbf{Intra-AS Routing (IGP):} Routing protocol used within an AS; focus is on performance.
    \item \textbf{Inter-AS Routing (EGP):} Routing protocol used between ASs; focus is on policy.
    \item \textbf{OSPF (Open Shortest Path First):} A widely used, open-standard, link-state, intra-AS routing protocol.
    \item \textbf{Link-State Advertisement (LSA):} A broadcast packet containing the state and cost of a router's links, used by OSPF.
    \item \textbf{Traffic Engineering:} Setting link costs to achieve network-wide performance goals (e.g., minimize congestion).
    \item \textbf{OSPF Area:} A sub-domain within a large AS used to create hierarchy and limit LSA flooding.
    \item \textbf{Backbone Area (Area 0):} The central area in a hierarchical OSPF network connecting all other areas.
    \item \textbf{Area Border Router (ABR):} A router that connects one or more areas to the backbone area.
\end{itemize}

\textbf{Core Relationships}

\begin{itemize}
    \item The Internet is divided into ASs to address issues of scale and administrative autonomy.
    \item This leads to a two-tier routing system: Intra-AS (e.g., OSPF) and Inter-AS (e.g., BGP).
    \item OSPF is a practical implementation of the Link-State algorithm (using Dijkstra’s).
    \item Routers flood LSAs to build an identical network map, then compute shortest paths independently.
    \item Large ASs use OSPF hierarchy (Areas + Backbone) to limit LSA flooding and reduce computation.
\end{itemize}

\textbf{Key Insights / Takeaways}

\begin{itemize}
    \item Internet routing is fundamentally hierarchical: Intra-AS and Inter-AS levels enable global scalability.
    \item OSPF is the canonical Intra-AS protocol, relying on the Link-State approach.
    \item OSPF offers robustness: authentication, multi-path load balancing, and hierarchical scalability.
    \item OSPF link costs are policy tools—not purely physical measurements—and can be tuned for Traffic Engineering.
\end{itemize}


\section{5.4 Routing Among the ISPs: BGP}

With OSPF, a link-state protocol, is designed for scalability and performance within a single administrative domain. All routes within AS are teammates, running the same protocol with the shared goal of finding the best-performing, least-cost paths.

\begin{enumerate}
    \item BGP
          \begin{enumerate}
              \item Fundamentally different from OSPF
              \item OSPF goal is performance, BGP's goal is policy
              \item Is a decentralized, async protocol that is similar in many ways to Distance-Vector algo
          \end{enumerate}
\end{enumerate}

\subsection{5.4.1 Role of BGP}

\begin{enumerate}
    \item Why do we need a separate protocol for inter-AS routing?
          \begin{enumerate}
              \item Reasons are scale and autonomy
              \item OSPF's 'everyone knows the full map' approach won't scale to hundreds of millions of routers on global internet
              \item Furthermore, an AS doesn't want to share its internal topology with competitors
          \end{enumerate}
    \item Fundamentals of BGP
          \begin{enumerate}
              \item Within an AS, a router uses its intra-AS protocol (OSPF) to find best path to any other router inside of AS1 (let's say router 1a in AS1), but what about a destination outside its AS, say a prefix x located in AS3?
              \item Router 1a's OSPF built forwarding table is useless for this. It needs mechanisms to:
                    \begin{enumerate}
                        \item Discover that prefix x even exists
                        \item Learn a path to prefix x
                        \item Choose best path from potentially many options, based on its AS's policies
                    \end{enumerate}
          \end{enumerate}
    \item Routing to Prefixes
          \begin{enumerate}
              \item Key distinction with BGP is that it doesn't route individual host IP addresses
              \item Routes to prefices, which are CIDRized blocks of addresses (e.g. 138.16.18/22) that represent a subnet or a collection of subnets
              \item Every router forwarding tbale is thus a combination of routes learned from two different sources
                    \begin{enumerate}
                        \item Intra-AS routes (from OSPF): typically for destiantions inside the AS
                        \item Inter-AS routes (from BGP): for destinations outside AS
                    \end{enumerate}
              \item BGP provides each router with means to:
                    \begin{enumerate}
                        \item Obtain prefix reachability information. BGP allows an AS to advertise its prefixes to rest of internet and ensures this advertisement propogates to all other ASs
                        \item Determine best route: a router might learn multiple paths to same prefix. For example, AS1 might learn it can reach x via AS2, or via direct link to AS3
                    \end{enumerate}
          \end{enumerate}
\end{enumerate}


\subsection{5.4.2 Advertising BGP Route Information}

\begin{enumerate}
    \item \textbf{Concept Overview: iBGP and eBGP}

          How does a prefix advertisement (e.g., ``AS3 has x'') get from a router deep inside AS3 to a router deep inside AS1?

          The process involves two ``flavors'' of BGP:

          \begin{itemize}
              \item \textbf{External BGP (eBGP):} Used to communicate between routers in different ASs.
              \item \textbf{Internal BGP (iBGP):} Used to communicate between routers within the same AS.
          \end{itemize}

          Before we see how they work, we must define two types of routers:

          \begin{itemize}
              \item \textbf{Gateway Router:} A router at the ``edge'' of an AS that has a direct physical link to a router in another AS (e.g., router 1c in Figure 5.8).
              \item \textbf{Internal Router:} A router that is connected only to other hosts and routers within its own AS (e.g., router 1b in Figure 5.8).
          \end{itemize}

    \item \textbf{Technical Mechanism: BGP Connections}

          Unlike OSPF, BGP does not send its messages raw over IP. BGP runs over TCP on port 179.

          A BGP connection (or BGP session) is the semi-permanent TCP connection between two routers running BGP.

          An eBGP connection is a BGP session that spans two ASs (e.g., between router 1c in AS1 and router 2a in AS2).

          An iBGP connection is a BGP session between routers in the same AS (e.g., between 1c and 1b in AS1).

          This is a critical point: iBGP connections are logical connections, not necessarily physical. As shown in Figure 5.9, the iBGP session between 1c and 1b runs over the AS1 network. The TCP packets that carry the BGP message from 1c to 1b are themselves routed by AS1's intra-AS protocol (OSPF).

          \textbf{Textual Representation of Figure 5.9: BGP Connections}

          \begin{verbatim}
         <--eBGP-->         <--eBGP-->
 (AS1) 1c ========= 2a (AS2) 2c ========= 3a (AS3)
   | \               |          |               |
   |  \ <--iBGP-->   |          | <--iBGP-->    |
   |   \             |          |               |
   |    1b           |          |      3b       |
   .    .            .          .      .       .
   .    .            .          .      .       .
(Full iBGP mesh inside each AS)
\end{verbatim}

    \item \textbf{Practical View: The Advertisement Propagation Chain}

          Let's trace the advertisement for prefix x from AS3 to all routers in AS1 (Figure 5.8/5.9):

          \begin{enumerate}
              \item \textbf{Start:} Router 3a (gateway) in AS3 advertises x to router 2c (gateway) in AS2 via an eBGP connection. The message is effectively: ``I can reach x''.
              \item \textbf{Internal Propagation (AS2):} Router 2c receives this advertisement. It must now inform all other routers in its own AS (AS2) about this new prefix. It sends an iBGP message to all its iBGP peers (e.g., 2a, 2b, 2d) saying ``I can reach x via 3a''.
              \item \textbf{Cross-AS Propagation:} Router 2a (gateway) now knows it can reach x. It advertises this fact to router 1c (gateway) in AS1 via their eBGP connection. The message is now: ``I can reach x, and the path is (AS2, AS3)''.
              \item \textbf{Internal Propagation (AS1):} Router 1c receives this advertisement. It uses iBGP to inform all its internal peers (1a, 1b, 1d) of this new route: ``I can reach x via the path (AS2, AS3)''.
          \end{enumerate}

          \textbf{End State:} Now, every router in AS1 and AS2 knows about prefix x and also knows the path of ASs required to get there.
\end{enumerate}

\subsection{5.4.3 Determining the Best Routes}

\begin{enumerate}

    \item \textbf{Concept Overview: BGP Routes and Attributes}

          In the previous example, AS1 learned one path to x. But in the real Internet (as in Figure 5.10), AS1 might learn multiple paths to x. For example, if AS1 also has a direct link to AS3, it might learn two paths:

          Path 1: (AS2, AS3, x)

          Path 2: (AS3, x)

          How does a router in AS1 choose? It uses BGP's route-selection algorithm.

          A route in BGP is more than just a prefix; it's the prefix plus its associated attributes. Two of the most important attributes are AS-PATH and NEXT-HOP.

    \item \textbf{Technical Mechanism: AS-PATH and NEXT-HOP Attributes}

          \textbf{AS-PATH:}

          \begin{itemize}
              \item \textbf{What it is:} This attribute contains the list of ASs that the advertisement has traversed.
              \item \textbf{How it's built:} When a prefix is advertised outside an AS, the AS prepends its own ASN to the list.
                    \begin{itemize}
                        \item 3a advertises (AS3, x) to 2c.
                        \item 2c propagates this internally.
                        \item 2a advertises to 1c, prepending its own AS: (AS2, AS3, x).
                    \end{itemize}
              \item \textbf{Function 1 (Loop Detection):} This is BGP's primary loop-detection mechanism. If a router receives an advertisement where its own AS is already in the AS-PATH, it rejects the route.
              \item \textbf{Function 2 (Metric):} The length of the AS-PATH (number of ASs) is used as a routing metric. Shorter paths are preferred.
          \end{itemize}

          \textbf{NEXT-HOP:}

          \begin{itemize}
              \item \textbf{What it is:} This is the IP address of the router interface that begins the AS-PATH.
              \item \textbf{Crucial Role:} This attribute is the critical link that connects the inter-AS (BGP) routing logic to the intra-AS (OSPF) forwarding logic.
          \end{itemize}

          Example (Figure 5.10):

          Router 1c learns the route (AS2, AS3, x) from router 2a. The NEXT-HOP for this route is the IP address of 2a's interface.

          Router 1d learns the route (AS3, x) from 3d. The NEXT-HOP for this route is the IP address of 3d's interface.

          When 1c and 1d advertise these routes internally via iBGP to router 1b, they include the original NEXT-HOP attribute.

          Router 1b's (internal) view:

          Route 1 for x: AS-PATH = (AS2, AS3), NEXT-HOP = \textless IP of 2a\textgreater

          Route 2 for x: AS-PATH = (AS3), NEXT-HOP = \textless IP of 3d\textgreater

    \item \textbf{Technical Mechanism: Hot Potato Routing}

          Given these two routes, how does 1b choose? The simplest policy is Hot Potato Routing.

          \textbf{Concept:} This is a ``selfish'' algorithm. The AS wants to get the packet ``off its network'' (like a hot potato) as quickly and cheaply as possible. It doesn't care about the cost outside its own network.

          Mechanism (Figure 5.11):

          \begin{itemize}
              \item Router 1b looks at the two routes it knows for x.
              \item It examines their NEXT-HOP attributes: \textless IP of 2a\textgreater{} and \textless IP of 3d\textgreater{}.
              \item 1b then consults its intra-AS (OSPF) routing table to find the internal cost to reach \textless IP of 2a\textgreater{} and the internal cost to reach \textless IP of 3d\textgreater{}.
              \item It selects the route whose NEXT-HOP is ``closer'' based on its internal OSPF costs.
          \end{itemize}

          If 2a is 2 hops away and 3d is 3 hops away, 1b chooses Route 1. It then looks at its OSPF forwarding table to find the local interface I that is on the shortest path to 2a, and it installs (x, I) in its forwarding table.

          \textbf{Key Insight:} Hot Potato Routing highlights the symbiosis of BGP and OSPF. BGP provides the external path options, and OSPF provides the internal costs to reach those external paths.

    \item \textbf{Technical Mechanism: The Full BGP Route-Selection Algorithm}

          Hot Potato Routing is just one step in the full algorithm. BGP routers are driven by policy. The full algorithm is a sequential list of rules. A router takes all known routes for a prefix and applies these rules in order until only one route is left.

          \begin{itemize}
              \item \textbf{Local Preference (POLICY):} Each route is assigned a local\_pref value by the router that learns it. This is a policy decision. The router must select the route with the highest local preference value, regardless of any other attribute.
              \item \textbf{Shortest AS-PATH (PERFORMANCE):} From the remaining routes (which are tied for the highest local\_pref), select the route with the shortest AS-PATH length.
              \item \textbf{Hot Potato Routing (COST):} From the remaining routes (which are tied on local\_pref and AS-PATH length), select the route with the closest NEXT-HOP router (based on intra-AS (OSPF) costs).
              \item \textbf{BGP Identifiers:} If still tied, use other BGP attributes (like router IDs) as a final tie-breaker.
          \end{itemize}

          Example Revisited: In Figure 5.10, 1b learns (AS2, AS3, x) and (AS3, x).

          Assume local\_pref is the same for both (Rule 1 tie).

          Rule 2 (Shortest AS-PATH) is applied. (AS3, x) has length 1. (AS2, AS3, x) has length 2.

          Router 1b selects the route (AS3, x).

          Notice that Hot Potato Routing (Rule 3) is not even used in this case, because the AS-PATH lengths were different. This shows BGP is not a purely selfish protocol; it does prefer shorter AS-level paths, unless policy (Rule 1) dictates otherwise.

\end{enumerate}

\subsection{5.4.4 IP-Anycast}

BGP's ``best path'' selection logic enables a powerful service called IP-Anycast, which is heavily used by the DNS system.

\textbf{Concept:} Replicate a service (like a DNS root server) in many different geographical locations, but assign the exact same IP address to all of them.

\textbf{Mechanism (Figure 5.12):}
\begin{itemize}
    \item The CDN server in AS1 advertises 212.21.21.21 via BGP.
    \item The CDN server in AS4 also advertises the same prefix 212.21.21.21 via BGP.
    \item A router in AS3 will receive two different routes for 212.21.21.21: one via AS1 and one via AS4.
    \item The router in AS3 simply runs its standard BGP route-selection algorithm. It will pick the ``best'' path (e.g., the one with the shortest AS-PATH) and install that route in its forwarding table.
\end{itemize}

\textbf{Result:} When a client in AS3 sends a packet to 212.21.21.21, the BGP-built forwarding tables will automatically route the packet to the ``closest'' server instance. This provides incredible robustness and low latency for critical services like DNS.

\subsection{5.4.5 Routing Policy}

As we've stressed, policy is the primary driver of BGP. The examples in Figure 5.13 illustrate the two most common policy relationships: provider-customer and peer-peer.

\textbf{Policy Example 1: Stub Networks (Customer/Provider)}
\begin{itemize}
    \item \textbf{Scenario:} X is a customer of B and C. W and Y are customers of A and C, respectively.
    \item \textbf{Goal:} X is a ``stub'' network. It should originate and terminate traffic, but it should never be a transit AS. That is, B should not send traffic destined for C through X.
    \item \textbf{Implementation (Policy):} X does not advertise routes learned from one provider (C) to its other provider (B).
    \item \textbf{Result:} Since B never learns a path to Y or C via X, it will never route traffic through X to get there. Policy is enforced by selectively choosing what routes to advertise.
\end{itemize}

\textbf{Policy Example 2: Peering (No ``Free Rides'')}
\begin{itemize}
    \item \textbf{Scenario:} B and C are peers. A is a customer of B.
    \item \textbf{Goal:} B and C agree to exchange traffic between their respective customers. B does not want to carry traffic from C to the rest of the Internet (e.g., to A) for free.
    \item \textbf{Implementation (Policy):}
          \begin{itemize}
              \item B learns a route to W via its customer A (path A-W).
              \item B will advertise this route (B-A-W) to its customer X (because X pays B for Internet transit).
              \item B will \emph{not} advertise this route (B-A-W) to its peer C.
          \end{itemize}
    \item \textbf{Result:} C never learns a path to W via B. C cannot use B as a ``free ride'' to get to A's customers.
\end{itemize}

\textbf{Rule of Thumb:} An ISP only carries traffic if it originates from or is destined to one of its own customers.

\paragraph{Sidebar: Why Different Inter-AS and Intra-AS Protocols?}

\textbf{Policy:} Inter-AS (BGP) is all about policy. It allows an AS to control what traffic it carries and what routes it advertises based on business relationships (customer, peer). Intra-AS (OSPF) has no concept of this; its only goal is to find the best technical path.

\textbf{Scale:} OSPF's ``everyone-knows-the-map'' (link-state flooding) approach does not scale to the hundreds of thousands of networks on the Internet. BGP (a DV-like protocol) scales by only advertising paths of ASs, not individual router links.

\textbf{Performance:} Intra-AS (OSPF) can be finely tuned for performance, using link costs to optimize latency or bandwidth. Inter-AS (BGP) often sacrifices performance for policy. A longer, more expensive path that satisfies a business agreement will be chosen over a shorter one that doesn't.


\subsection{5.4.6 Putting the Pieces Together: Obtaining Internet Presence}

This section provides a perfect case study integrating everything from Chapter 2, 4, and 5.

\textbf{Goal:} Your new company, Xanadu Inc., wants to connect its network (Web, mail, DNS servers) to the global Internet.

\textbf{The Protocol Checklist:}

\begin{itemize}
    \item \textbf{Get Physical:} Contract with a local ISP. You get a physical link and a block of IP addresses (a CIDR prefix, e.g., /24) from your ISP.
    \item \textbf{Configure Local Network (IP/DHCP):} You assign IP addresses from your block to your gateway router and your servers. You might use DHCP (Chapter 4) to assign addresses to your internal employee hosts.
    \item \textbf{Get a Name (DNS):} You register your domain name (e.g., xanadu.com) with a DNS registrar.
    \item \textbf{Register Your DNS Server (DNS):} You must tell the registrar the name and IP address of your company's authoritative DNS server. The registrar then inserts an NS record (Name Server record) into the .com TLD servers, ``delegating'' xanadu.com to your server's IP address.
    \item \textbf{Populate Your DNS Server (DNS):} In your own DNS server, you create the resource records for your company:
          \begin{itemize}
              \item An A record mapping \texttt{www.xanadu.com} to your Web server's IP address.
              \item An MX record mapping \texttt{xanadu.com} to your mail server's name.
          \end{itemize}
    \item \textbf{Get Global Reachability (BGP):} This is the final, essential step. Your ISP's gateway router must advertise your prefix (your /24 block) to its upstream providers using eBGP. This advertisement then propagates via BGP across the entire Internet.
\end{itemize}

\textbf{The Result (A Day in the Life):}

\begin{itemize}
    \item When a user types \texttt{www.xanadu.com}:
          \begin{itemize}
              \item Their DNS query (Chapter 2) goes to a root server, then a .com TLD server.
              \item The TLD server sees the NS record (Step 4) and directs the query to your DNS server.
              \item Your DNS server replies with the A record (Step 5), giving the user your Web server's IP.
          \end{itemize}
    \item When the user's browser sends a TCP SYN (Chapter 3) to that IP:
          \begin{itemize}
              \item Every router on the Internet uses its forwarding table—built by BGP (Step 6)—to find the AS-PATH toward your ISP, and ultimately, to your network.
              \item The packet arrives at your gateway router.
              \item Your gateway router uses its internal (e.g., OSPF) forwarding table to send the packet to the final destination: your Web server.
          \end{itemize}
\end{itemize}

\subsection{5.4 Section-Wide Summary}

\textbf{Key Terms and Definitions:}

\begin{itemize}
    \item \textbf{BGP (Border Gateway Protocol):} The de facto inter-AS (inter-domain) routing protocol for the global Internet.
    \item \textbf{Inter-AS vs. Intra-AS:} Inter-AS is between autonomous systems (policy-driven); Intra-AS is within an autonomous system (performance-driven).
    \item \textbf{Gateway Router:} An AS-edge router that connects to a router in another AS.
    \item \textbf{Internal Router:} A router that only connects to devices within its own AS.
    \item \textbf{eBGP:} The BGP session between two different ASs. Used to advertise external routes.
    \item \textbf{iBGP:} The BGP session within an AS. Used to propagate external routes to all internal routers.
    \item \textbf{BGP Connection:} A logical session running on TCP port 179.
    \item \textbf{Route:} In BGP, a route is a prefix + attributes.
    \item \textbf{AS-PATH Attribute:} The list of ASs an advertisement has traversed. Used for loop detection and as a metric (shorter is better).
    \item \textbf{NEXT-HOP Attribute:} The IP address of the next router on the external path. This is the crucial link between BGP (inter-AS) and OSPF (intra-AS).
    \item \textbf{Hot Potato Routing:} A ``selfish'' routing policy where an AS forwards a packet to the internally closest exit point (NEXT-HOP), regardless of the external path cost.
    \item \textbf{Route Selection Algorithm:} The 4-step process BGP uses to select a single ``best'' route: 1. Highest Local Preference (Policy), 2. Shortest AS-PATH, 3. Closest NEXT-HOP (Hot Potato), 4. Tie-breakers.
    \item \textbf{IP-Anycast:} A service (used by DNS) where a single IP address is assigned to multiple, geographically dispersed servers, and BGP's route selection automatically directs clients to the ``closest'' one.
\end{itemize}

\textbf{Core Relationships:}

\begin{itemize}
    \item BGP is the ``glue'' of the Internet, connecting all the ASs.
    \item BGP uses eBGP to talk to other ASs and iBGP to inform its own internal routers.
    \item The BGP Route Selection Algorithm shows the priority of Policy (Local Preference) over Performance (AS-PATH, Hot Potato).
    \item A router's final forwarding table is built using both BGP (to find the exit gateway/NEXT-HOP for external prefixes) and OSPF (to find the internal path to that NEXT-HOP).
\end{itemize}

\textbf{Key Insights / Takeaways:}

\begin{itemize}
    \item Inter-domain routing (BGP) is not about finding the best path; it's about finding a policy-compliant path that works. Business relationships (customer/provider, peer/peer) dictate routing, not just link speeds.
    \item BGP is a Path Vector protocol, a ``DV-like'' protocol. Instead of just advertising a cost (distance), it advertises the entire path (the AS-PATH attribute). This is what allows it to implement policy and detect loops robustly.
    \item A router in an AS makes its ``best'' choice based on the information it has. Hot Potato Routing is the classic example of this ``selfish'' behavior: minimize my cost, and let the next AS worry about its cost.
    \item The Internet is a ``network of networks.'' To ``join'' the Internet, you need more than a physical link and an IP address; your AS must participate in BGP so the rest of the world can learn a route to your prefixes.
\end{itemize}

\section{5.5 The SDN Control Plane}
\begin{itemize}
    \item In our previous lectures, we have established a critical architectural principle: the separation of the network layer's data plane (the local, per-router forwarding of packets) from its control plane (the network-wide logic that determines how packets should be forwarded). We have studied the traditional implementation of the control plane, per-router control, where a routing algorithm (like OSPF or BGP) runs in every single router.
    \item Today, we study the second, and revolutionary, approach: logically centralized control, which is the foundation of Software-Defined Networking (SDN). In this model, the control plane is physically removed from the routers and implemented in a separate, remote controller. This "unbundling" of the network has profound implications for how networks are designed, managed, and programmed.
\end{itemize}

\subsection{5.5.1 The Four Key Characteristics of an SDN Architecture}
\begin{enumerate}
    \item SDN is not a single protocol but an architectural approach defined by four key characteristics:
          \begin{itemize}
              \item Flow-based Forwarding:
                    \begin{itemize}
                        \item This is the data plane mechanism that SDN controls. We studied this in Chapter 4 as "generalized forwarding".
                        \item Unlike traditional routing, which forwards packets based only on the destination IP address, SDN-controlled switches (which we call "packet switches") use a flow table.
                        \item This flow table implements the "match-plus-action" paradigm. A "match" can be made on numerous header fields across multiple layers (e.g., L2 MAC address, L3 IP address, L4 TCP/UDP port).
                        \item The "action" is also general: it can be to forward, drop, modify, or send the packet to the controller. It is the SDN control plane's job to compute, install, and manage these flow table entries.
                    \end{itemize}
              \item Separation of Data Plane and Control Plane:
                    \begin{itemize}
                        \item This is the core philosophy of SDN.
                        \item The data plane consists of the network's switches. These are now "dumb" (but fast) hardware devices whose only job is to execute the match-plus-action rules in their flow tables.
                        \item The control plane consists of the remote servers and software (the "brain") that determine and manage these flow tables.
                    \end{itemize}
              \item Network Control Functions are External to Data-Plane Switches:
                    \begin{itemize}
                        \item This highlights that the control plane is physically separate from the data-plane switches.
                        \item As shown in Figure 5.14, the control plane itself is composed of two parts:
                              \begin{itemize}
                                  \item The SDN Controller (or Network Operating System): This is the core platform. It maintains a centralized view of the network's state (links, switches, hosts) and provides an API for applications to interact with it.
                                  \item Network-Control Applications: These are the "apps" that run on the controller. They contain the actual logic for network functions like routing, load balancing, or firewalling. They use the controller's API to specify the desired behavior.
                              \end{itemize}
                        \item The controller is "logically centralized," meaning it presents a single, unified view of the network. In practice, it's a physically distributed system (run on multiple servers) for fault tolerance and scalability.
                    \end{itemize}
              \item A Programmable Network:
                    \begin{itemize}
                        \item This is the payoff of the first three characteristics. The network becomes programmable via the network-control applications.
                        \item Analogy (The PC vs. Mainframe): The textbook correctly likens this to the "unbundling" of the PC from the monolithic mainframe.
                        \item Old Model (Mainframe/Traditional Router): A single vendor (e.g., IBM, Cisco) sold you a "vertically integrated" box containing the hardware, the operating system (e.g., IOS), and the applications (e.g., OSPF, BGP).
                        \item New Model (PC/SDN): The architecture is "unbundled" and open. You can get (1) data-plane switch hardware from one vendor, (2) an SDN controller OS from another (or open-source), and (3) network-control apps from a third vendor, or write them yourself. This open ecosystem is designed to drive innovation.
                    \end{itemize}
          \end{itemize}
\end{enumerate}

\subsection{5.5.1 The SDN Control Plane: Controller and Applications}
\begin{enumerate}
    \item Let's now look inside the "brain"—the SDN controller itself. The controller's architecture is typically organized into three layers, as shown in the textbook's Figure 5.15.
    \item Textual Representation of Figure 5.15: SDN Controller Architecture
          \begin{itemize}
              \item +-------------------------------------------------+
              \item |        Network-Control Applications             | (e.g., Routing, Access Control, Load Balancer)
              \item +-------------------------------------------------+
              \item |              NORTHBOUND API (RESTful, Intent)   |
              \item +=================================================+
              \item |          SDN Controller (Network OS)            |
              \item |                                                 |
              \item |    [ Network-Wide State Management Layer ]      |
              \item | (Link state, Host info, Switch info, Statistics,|
              \item |           Flow tables, Network graph)           |
              \item |                                                 |
              \item |-------------------------------------------------|
              \item |             Communication Layer                 |
              \item +=================================================+
              \item |              SOUTHBOUND API (OpenFlow, SNMP)    |
              \item +-------------------------------------------------+
              \item |       SDN-Controlled Network Devices            | (Switches)
              \item +-------------------------------------------------+
          \end{itemize}
    \item We will examine these layers from the bottom-up.
    \item The Communication Layer (Southbound Interface)
          \begin{itemize}
              \item Purpose: This layer provides the communication channel between the SDN controller and the network's data-plane switches. This is the Southbound API.
              \item Mechanism: It requires a standardized protocol for two-way communication:
                    \begin{itemize}
                        \item Controller-to-Device: To send commands (e.g., "Install this flow rule").
                        \item Device-to-Controller: To report events (e.g., "A link just failed," "A new host just connected," or "A packet arrived that I don't have a rule for").
                    \end{itemize}
              \item Example Protocol: The most prominent southbound protocol is OpenFlow, which we will detail next.
          \end{itemize}
    \item The Network-Wide State-Management Layer
          \begin{itemize}
              \item Purpose: This is the controller's "single source of truth." It maintains a real-time, comprehensive view of the entire network's state.
              \item Mechanism: This layer is essentially a distributed database that stores all network-state information, including:
                    \begin{itemize}
                        \item The state of all hosts, links, and switches.
                        \item Statistics and counters from the switches' flow tables.
                        \item A copy of the flow tables installed on all switches.
                        \item A high-level "network graph" or topology map.
                    \end{itemize}
              \item Practical View (Logical Centralization): This state must be consistent, reliable, and scalable. In production-grade controllers, this "state management layer" is a sophisticated, physically distributed database that uses distributed systems techniques (like consensus algorithms) to provide a logically centralized but physically distributed and fault-tolerant service.
          \end{itemize}
    \item The Interface to Applications (Northbound Interface)
          \begin{itemize}
              \item Purpose: This layer is the Northbound API that the network-control "apps" use to interact with the controller (the network "OS").
              \item Mechanism: The API allows an application to:
                    \begin{itemize}
                        \item Read State: "Give me the current network graph." "Tell me the statistics for flow X."
                        \item Write State: "Install this set of flow rules in switches S1 and S2."
                        \item Register for Notifications: "Notify me whenever a link fails" or "Tell me when a new host appears on the network."
                    \end{itemize}
              \item Example APIs: Many controllers expose a RESTful API (using HTTP) for this interface, allowing for easy, language-independent application development.
          \end{itemize}
    \item Practical Implementation: ODL and ONOS (from Sidebar)
          \begin{itemize}
              \item The OpenDaylight (ODL) Controller:
                    \begin{itemize}
                        \item Key Component: The Service Abstraction Layer (SAL) acts as the central "message bus" or "nerve center" of the controller.
                        \item Southbound: The SAL provides a uniform interface to plug in various southbound protocols like OpenFlow, SNMP, and NETCONF (which we'll see in 5.7).
                        \item Northbound: ODL provides two APIs for apps:
                              \begin{itemize}
                                  \item API-Driven (AD-SAL): A REST-based API for direct command-and-response.
                                  \item Model-Driven (MD-SAL): A more advanced API where the network's configuration and state are modeled using the YANG data-modeling language. Applications then manipulate this data model, and the controller (using NETCONF) ensures the real network's state matches the model.
                              \end{itemize}
                    \end{itemize}
              \item The ONOS Controller:
                    \begin{itemize}
                        \item Key Component: The ONOS Distributed Core is built from the ground up as a distributed system, running as an identical service on a set of servers to provide scalability and fault tolerance.
                        \item Southbound: Uses abstractions to mask the specific protocols (like OpenFlow) from the core logic.
                        \item Northbound (Intent Framework): This is a key innovation. ONOS provides a higher-level API. Instead of an app saying "Install rule X on switch Y," it states its intent:
                              \begin{itemize}
                                  \item e.g., "I intend for Host A and Host B to be connected."
                                  \item e.g., "I intend for Host A and Host C to never communicate."
                              \end{itemize}
                        \item The ONOS controller itself is then responsible for translating this high-level "intent" into the specific set of low-level flow rules required on all the switches to make it happen.
                    \end{itemize}
          \end{itemize}
\end{enumerate}

\subsection{5.5.2 OpenFlow Protocol}
\begin{enumerate}
    \item Concept Overview
          \begin{itemize}
              \item OpenFlow is the most prominent protocol for the southbound API, defining the communication between an SDN controller and an SDN-controlled switch. It runs over TCP (port 6653) and allows the controller to manage the switch's flow table.
          \end{itemize}
    \item Technical Mechanism: Key Message Types
          \begin{itemize}
              \item OpenFlow messages flow in both directions:
              \item Messages from Controller-to-Switch (Command):
                    \begin{itemize}
                        \item Configuration: Used by the controller to query and set configuration parameters on the switch.
                        \item Modify-State: The "workhorse" message. Used to add, delete, and modify flow entries in the switch's flow table. This is how the controller programs the data plane.
                        \item Read-State: Used to retrieve statistics and counters from the switch's flow tables and ports (e.g., "How many packets have matched rule 5?").
                        \item Send-Packet: This message, sent from the controller, actually contains a packet in its payload. It instructs the switch to send this packet out of a specific port. This is useful for injecting control-plane-generated packets (like ARP or probe packets) into the data plane.
                    \end{itemize}
              \item Messages from Switch-to-Controller (Reporting):
                    \begin{itemize}
                        \item Flow-Removed: Informs the controller that a flow table entry has been removed (e.g., because its inactivity timer expired).
                        \item Port-status: Informs the controller of a change in a port's status (e.g., link up, link down). This is critical for updating the network-wide state.
                        \item Packet-in: This is the other "workhorse" message. When a packet arrives at a switch and finds no match in the flow table, the switch sends this Packet-in message to the controller. The message contains the unmatched packet's header (or the full packet). This message is the trigger that tells the controller, "A new, unknown flow has arrived. I need instructions."
                    \end{itemize}
          \end{itemize}
    \item Practical View: Google's B4 Network (from Sidebar)
          \begin{itemize}
              \item The textbook provides Google's B4 network as a case study of a massive, globally deployed SDN.
              \item What it is: A private Wide-Area Network (WAN) that interconnects all of Google's global data centers.
              \item Architecture: It is a classic SDN.
                    \begin{itemize}
                        \item Data Plane: Custom-built switches running a version of OpenFlow.
                        \item Control Plane: A logically centralized, physically distributed set of OpenFlow Controllers (OFCs), which are part of a Network Control Server (NCS).
                        \item Applications: A high-level Traffic Engineering (TE) application runs on top of the controller.
                        \item Key Benefit: The TE application has a global view of all traffic demands and all link states. It can compute and install flow rules that split large data-copy flows across multiple paths simultaneously. This allows Google to run its WAN links at near 70\% utilization, 2-3 times higher than a traditional network, saving billions of dollars.
                    \end{itemize}
          \end{itemize}
\end{enumerate}

\subsection{5.5.3 Data and Control Plane Interaction: An Example}
\begin{enumerate}
    \item Let's synthesize all these concepts by tracing the complete, step-by-step process of reacting to a link failure in an SDN network.
    \item Scenario (Figure 5.16):
          \begin{itemize}
              \item An SDN controller is managing a network of switches (s1, s2, s3, s4).
              \item A "Link-State Routing" application (Dijkstra's) is running on the controller, and its goal is to maintain least-cost paths.
              \item The link between switch s1 and switch s2 fails.
          \end{itemize}
    \item Sequence of Events:
          \begin{itemize}
              \item Data Plane Event: The link s1-s2 physically fails. Switch s1 (and s2) detects this failure on its port.
              \item Southbound Notification (Switch-to-Controller): s1 sends an OpenFlow Port-status message to the SDN controller, reporting that its port connected to s2 is now "down".
              \item Controller State Update: The controller's Communication Layer receives the Port-status message. It passes this event "up" to the State-Management Layer. The "link-state manager" (or topology graph) in the controller's database is updated to reflect that the s1-s2 link is broken.
              \item Northbound Notification (Controller-to-Application): The Link-State Routing application had previously registered with the controller, asking to be notified of any link-state changes. The controller now sends a notification up to this application.
              \item Application Logic Execution: The Link-State Routing app "wakes up."
                    \begin{itemize}
                        \item It performs a Read State action via the Northbound API, requesting the new network graph from the State-Management Layer.
                        \item It runs its algorithm (e.g., Dijkstra's) on this new graph to re-compute all least-cost paths.
                        \item It identifies all the flow table entries that must be changed (e.g., on s1, s3, and s4) to reflect these new paths.
                    \end{itemize}
              \item Northbound Command (Application-to-Controller): The application sends the new set of flow rules (e.g., "packets from s1 to s2 must now go via s4") down to the controller via the Northbound API, instructing the "flow table manager" to update the network.
              \item Southbound Command (Controller-to-Switch): The controller's Communication Layer translates these rules into OpenFlow Modify-State messages and sends them to the data-plane switches s1, s3, and s4.
              \item Data Plane Action: The switches receive the Modify-State messages and install the new rules in their flow tables.
              \item Result: The network has converged to the new topology. The entire process was orchestrated by a single, logically centralized software application. This is profoundly different from the OSPF model, where every router would have had to independently receive a flood of messages and independently re-run Dijkstra's algorithm.
          \end{itemize}
\end{enumerate}

\subsection{5.5.4 SDN: Past and Future}
\begin{enumerate}
    \item Past: The Origins of SDN
          \begin{itemize}
              \item The textbook notes that the "unbundling" idea has a long history.
              \item Researchers in the 1990s and early 2000s argued for separating the control and data planes (e.g., in ATM networks and in proposals like ForCES [RFC 3746]).
              \item The direct ancestor of OpenFlow was the Ethane project at Stanford (2007). It pioneered the core SDN concepts: a centralized controller, simple flow-based switches, and the "unmatched packets go to the controller" rule.
              \item Ethane evolved into OpenFlow, and the SDN movement was born.
          \end{itemize}
    \item Future: Network Functions Virtualization (NFV)
          \begin{itemize}
              \item SDN is a disruptive "unbundling" of the router. The next logical step is to unbundle all the other "middleboxes" in the network.
              \item NFV (Network Functions Virtualization): This is an approach that aims to replace proprietary, dedicated hardware for middleboxes (like firewalls, load balancers, and caches) with software running on commodity hardware (standard servers, switches, and storage).
              \item This is the same architectural principle as SDN, applied to middleboxes. It allows network operators to spin up a new "virtual" firewall or "virtual" load balancer as a piece of software on a server, rather than having to buy and install a new physical appliance.
          \end{itemize}
    \item Future: Inter-AS SDN
          \begin{itemize}
              \item A major area of research is extending SDN's centralized control concepts from the intra-AS setting (where there is one owner) to the inter-AS setting (where competing ISPs must cooperate).
          \end{itemize}
\end{enumerate}

\subsection{5.5 Section-Wide Summary}
\begin{enumerate}
    \item Key Terms and Definitions:
          \begin{itemize}
              \item SDN (Software-Defined Networking): An architectural approach that separates the data plane (hardware switches) from the control plane (software controller).
              \item Flow-Based Forwarding: The "match-plus-action" data plane model used by SDN switches.
              \item SDN Controller (Network OS): The "brain" of the network. A logically centralized, physically distributed software platform that manages the network's state and programs the switches.
              \item Network-Control Application: Software that runs on the controller and implements specific network logic (e.g., routing, firewalling).
              \item Southbound API: The interface/protocol between the controller and the switches (e.g., OpenFlow).
              \item Northbound API: The interface/protocol between the controller and the network-control applications (e.g., a REST API or Intent Framework).
              \item OpenFlow: The most common southbound protocol. Its key messages include Modify-State (controller-to-switch) and Packet-in (switch-to-controller).
              \item NFV (Network Functions Virtualization): The concept of unbundling middlebox functions (like firewalls) from proprietary hardware and running them as software on commodity servers.
          \end{itemize}
    \item Core Relationships:
          \begin{itemize}
              \item SDN is the architectural approach that separates the control and data planes.
              \item Generalized Forwarding ("match-plus-action") is the data-plane abstraction that SDN controls.
              \item OpenFlow is the southbound protocol that allows the SDN Controller to program the flow tables in the data-plane switches.
              \item Network-Control Applications use the controller's Northbound API to implement logic (like routing) by reading the network state and writing new flow rules.
              \item NFV is a "cousin" of SDN; both apply the principle of "unbundling" (separating software logic from commodity hardware) to network devices.
          \end{itemize}
    \item Key Insights / Takeaways:
          \begin{itemize}
              \item SDN's primary innovation is unbundling the traditional, monolithic router, which is analogous to the shift from mainframes to the open PC ecosystem. This separation is what makes the network "software-defined."
              \item The SDN controller is logically centralized (providing a single, unified view of the network) but physically distributed (for reliability and scale). This is a classic, large-scale distributed system.
              \item The control plane is layered, just like the protocol stack. At the bottom, the Southbound API (OpenFlow) talks to hardware. In the middle, the Controller (ODL, ONOS) manages state. At the top, the Northbound API (REST, Intent) allows applications to program the network's behavior.
              \item The "intelligence" of the network moves from the protocol (e.g., OSPF) to the application (a routing app running on the controller). This makes network logic easier to change, debug, and innovate.
              \item The Packet-in (switch-to-controller) and Modify-State (controller-to-switch) messages are the two most fundamental interactions in an SDN, representing the "reactive" loop of network control.
          \end{itemize}
\end{enumerate}


\section{5.6 ICMP: The Internet Control Message Protocol}

\subsection{5.6.1 Concept Overview: The ``Nervous System'' of the Network Layer}
\begin{itemize}
    \item In our study of the Internet Protocol (IP) in Chapter 4, we established that IP's service model is "best-effort." This means IP provides no guarantees—it simply tries its best to forward datagrams. But what happens when things go wrong?
    \item What happens if a router receives a datagram with a destination it can't reach?
    \item What happens if a datagram's Time-to-Live (TTL) field expires?
    \item What happens if a host receives a UDP segment for a port that isn't open?
    \item In a "best-effort" world, the router or host could just silently discard the packet. This, however, would leave the sending host completely in the dark, unable to diagnose the problem.
    \item To solve this, the network layer needs a "messenger service"—a mechanism for hosts and routers to communicate about the state of the network with each other. This is the Internet Control Message Protocol (ICMP).
    \item Definition: ICMP is used by hosts and routers to communicate network-layer information to each other.
    \item Primary Purpose: Its most common use is for error reporting. For example, if you've ever seen a "Destination network unreachable" error, you've seen the result of an ICMP message.
    \item Secondary Purpose: ICMP is also used for network-layer diagnostics, most famously by the ping and traceroute utilities.
\end{itemize}

\subsection{5.6.2 Technical Mechanism: ICMP's Architectural Placement}
\begin{itemize}
    \item A common point of confusion is where ICMP fits into the protocol stack.
    \item Analogy: ICMP is to IP as an "out-of-office" reply is to email. It's not a typical user-to-user message (like TCP/UDP), but rather a control/status message that functions at the same level as the protocol it supports.
    \item Architectural Position:
          \begin{enumerate}
              \item ICMP is often considered part of IP, but architecturally, it lies just above IP.
              \item An ICMP message is carried inside an IP datagram, just like a TCP or UDP segment.
              \item When an IP datagram arrives at a host or router, the device checks the Protocol field in the IP header (which we saw in Chapter 4).
              \item If Protocol == 6, the payload is passed to TCP.
              \item If Protocol == 17, the payload is passed to UDP.
              \item If Protocol == 1, the payload is passed to the ICMP handler.
          \end{enumerate}
    \item ICMP Message Format:
          \begin{enumerate}
              \item ICMP messages have a Type field and a Code field. The Type specifies the general class of message (e.g., "Destination Unreachable"), and the Code provides more specific information (e.g., "Host Unreachable").
          \end{enumerate}
    \item Crucial Feature: To provide context, an ICMP error message must include the entire IP header and the first 8 bytes of the original IP datagram that caused the error.
    \item Why is this payload important? The first 8 bytes of the original datagram's payload contain the TCP or UDP source and destination port numbers. This allows the receiving host's OS to determine which application (e.g., which web browser tab, which SSH session) generated the datagram that failed, so it can report the error to the correct process.
\end{itemize}

\subsection{5.6.3 Practical View 1: Key ICMP Message Types}
\begin{itemize}
    \item ICMP is not just for errors; it's also for queries. Figure 5.19 in the textbook provides a table of common types.
    \item Textual Representation of Figure 5.19: Common ICMP Message Types
          \begin{itemize}
              \item Type 0, Code 0: Echo reply (response to a ping)
              \item Type 3, Code 0: Destination network unreachable
              \item Type 3, Code 1: Destination host unreachable
              \item Type 3, Code 2: Destination protocol unreachable
              \item Type 3, Code 3: Destination port unreachable
              \item Type 4, Code 0: Source quench (a deprecated congestion control message)
              \item Type 8, Code 0: Echo request (the ping command)
              \item Type 9, Code 0: Router advertisement
              \item Type 10, Code 0: Router discovery
              \item Type 11, Code 0: TTL expired (used by traceroute)
              \item Type 12, Code 0: IP header bad (e.g., invalid field)
          \end{itemize}
    \item This table provides the "vocabulary" for IP-level communication.
\end{itemize}

\subsection{5.6.4 Practical View 2: The ping Utility}
\begin{itemize}
    \item The ping program is the most basic network-layer diagnostic tool. Its sole purpose is to answer the question: "Is that host alive and can I reach it?"
    \item How it Works:
          \begin{enumerate}
              \item The ping program on the source host sends an ICMP Type 8, Code 0 message (an "echo request") to the destination host's IP address.
              \item The network layer at the destination host receives this ICMP packet. Its IP layer demultiplexes it to its internal ICMP handler.
              \item The ICMP handler sees it's an echo request and immediately constructs and sends an ICMP Type 0, Code 0 message (an "echo reply") back to the source host.
          \end{enumerate}
    \item Implementation: The ping client (the program you run) is an application-layer process. However, the ping server (the part that responds) is not a user process. It is almost always implemented as part of the operating system's kernel, directly within the network layer.
\end{itemize}

\subsection{5.6.5 Practical View 3: The traceroute Utility}
\begin{itemize}
    \item The traceroute program is one of the most clever and powerful diagnostic tools. It uses ICMP in an ingenious way to discover the router-by-router path from a source to a destination.
    \item The Goal: To identify every router on the path and measure the Round-Trip Time (RTT) to each one.
    \item The Mechanism (a brilliant "hack" on the IP header):
          \begin{enumerate}
              \item The traceroute program on the source host constructs a series of IP datagrams, all addressed to the final destination.
              \item These datagrams contain a UDP segment with a port number that is intentionally invalid (i.e., one that is very unlikely to be in use at the destination).
          \end{enumerate}
    \item The Key Trick: The source manipulates the Time-to-Live (TTL) field of these datagrams.
          \begin{enumerate}
              \item It sends the first datagram with TTL = 1.
              \item It sends the second datagram with TTL = 2.
              \item It sends the third datagram with TTL = 3, and so on.
              \item The source starts a timer for each datagram sent.
          \end{enumerate}
    \item The Chain of Events:
          \begin{itemize}
              \item Datagram 1 (TTL=1): This packet is sent. It arrives at the first router on the path. The router decrements the TTL from 1 to 0. Per IP protocol rules, the router discards the datagram. It then generates an ICMP "TTL expired" message (Type 11, Code 0) and sends it back to the source.
              \item Result: The source receives this ICMP message. It stops the timer for the first datagram, records the RTT, and extracts the router's IP address and name. It now knows the first hop.
              \item Datagram 2 (TTL=2): This packet is sent. It arrives at the first router, which decrements the TTL to 1 and forwards it. The packet then arrives at the second router, which decrements the TTL from 1 to 0, discards the datagram, and sends back an ICMP "TTL expired" message.
              \item Result: The source receives this second ICMP message, stops the second timer, and records the identity and RTT of the second hop.
              \item This process continues, with each successive datagram getting one hop further into the network, "interrogating" each router along the path in sequence.
          \end{itemize}
    \item How does it stop?
          \begin{itemize}
              \item Eventually, a datagram will have a high-enough TTL to pass through all routers and reach the final destination host.
              \item The host's IP layer receives this datagram. The TTL is not expired, so it's a valid packet. The IP layer inspects the protocol field and sees "UDP".
              \item The datagram's payload is passed up to the UDP handler.
              \item UDP looks at the destination port number, finds it to be invalid, and sees that no application is listening there.
              \item The host's OS then generates an ICMP "port unreachable" (Type 3, Code 3), and sends this back to the source.
          \end{itemize}
    \item Final Result: When the source traceroute program receives this "port unreachable" message, it knows it has successfully reached the final destination and the trace is complete.
\end{itemize}

\subsection{5.6.6 A Note on ICMPv6}
\begin{itemize}
    \item A new version, ICMPv6, is defined in [RFC 4443] for the IPv6 protocol.
    \item It serves the same fundamental purposes (error reporting, diagnostics).
    \item It reorganizes the message types and codes to be more logical.
    \item It adds new message types that are essential for IPv6's new functionality.
    \item Example: The "Packet Too Big" message. Recall from Chapter 4 that IPv6 routers do not fragment packets. If a router receives a packet that is too large for the outgoing link, it drops the packet and sends this ICMPv6 message back to the source, telling it to resend using a smaller packet size.
\end{itemize}

\subsection{5.6.7 Section-Wide Summary}
\begin{itemize}
    \item Key Terms and Definitions:
          \begin{itemize}
              \item ICMP (Internet Control Message Protocol): A network-layer support protocol for hosts and routers to exchange control, error, and diagnostic information.
              \item ICMP Message: An IP payload (Protocol 1) that includes a Type, a Code, and the header + first 8 bytes of the IP datagram that triggered it.
              \item ping: A diagnostic utility that uses ICMP Type 8 (Echo Request) and Type 0 (Echo Reply) to check host reachability and RTT.
              \item traceroute: A diagnostic utility that maps a network path by sending UDP datagrams with increasing TTLs to trigger ICMP Type 11 (TTL Expired) messages from each router, and an ICMP Type 3 (Port Unreachable) from the final destination.
              \item ICMPv6: The updated version for IPv6, which adds new functionality like the "Packet Too Big" message.
          \end{itemize}
    \item Core Relationships:
          \begin{itemize}
              \item ICMP is not a transport protocol. It is a peer to TCP and UDP within the IP ecosystem, but it serves the network layer itself.
              \item ICMP's "payload" (the original datagram header) is a "feedback" mechanism, allowing a host to identify which of its packets and which of its applications caused an error.
              \item The ping and traceroute tools are practical, everyday applications built entirely on the ICMP message structure.
          \end{itemize}
    \item Key Insights / Takeaways:
          \begin{itemize}
              \item IP's "best-effort" service model would be un-debuggable without a feedback mechanism. ICMP provides this essential feedback.
              \item ICMP is the source of many of the common network errors you see, such as "Destination Unreachable."
              \item The traceroute program is a beautiful example of protocol "hacking" in the positive sense: it uses the standard, expected behavior of routers (decrementing TTL and sending an ICMP error on expiry) to build a powerful network-mapping tool.
              \item ICMP is not just for errors; it is also for querying (e.g., ping).
          \end{itemize}
\end{itemize}



\section{5.7 Network Management and SNMP, NETCONF/YANG}

\subsection{5.7.1 The Network Management Framework}
\begin{enumerate}
    \item In our previous lectures, we have focused almost exclusively on one aspect of the control plane: routing. We've studied how protocols like OSPF and BGP build the forwarding tables that get packets from source to destination.
    \item However, a network operator's job involves far more than just routing. A network is a complex, dynamic system with thousands of interacting hardware and software components. Keeping this system "up and running" involves a broad set of activities. This is the domain of network management.
    \item The textbook offers an excellent, comprehensive definition:
          \begin{itemize}
              \item "Network management includes the deployment, integration, and coordination of the hardware, software, and human elements to monitor, test, poll, configure, analyze, evaluate, and control the network and element resources to meet the real-time, operational performance, and Quality of Service requirements at a reasonable cost."
          \end{itemize}
    \item Our focus today is on the architecture, protocols, and data that network administrators use to perform these tasks. We will explore the traditional framework (SNMP) and the modern, SDN-era framework (NETCONF/YANG).
    \item Managing Server (The "Manager"):
          \begin{itemize}
              \item What it is: This is the application, typically with a human network manager in the loop, that runs in the Network Operations Center (NOC).
              \item Its Role: It's the central ``command and control'' station. It initiates actions to configure, monitor, and control the network. It collects, processes, and analyzes all the data from the network devices. In an SDN world, this is the controller.
          \end{itemize}
    \item Managed Device (The "Employee"):
          \begin{itemize}
              \item What it is: Any piece of network equipment (or its software) that resides on the managed network. This includes routers, switches, hosts, firewalls, modems, and even network-connected thermometers.
              \item Its Role: It is the device that "does the work" and needs to be managed.
          \end{itemize}
    \item Data (The "Information"):
          \begin{itemize}
              \item What it is: This is the "state" associated with each managed device, which the managing server needs to read and write. This data falls into three categories:
              \item Configuration Data: Information set by the manager (e.g., setting a router interface's IP address, configuring OSPF link weights).
              \item Operational Data: Information the device acquires as it runs (e.g., the list of OSPF neighbors it has discovered, the current forwarding table).
              \item Device Statistics: Status indicators and counters (e.g., number of dropped packets on an interface, fan speed, CPU load).
          \end{itemize}
    \item Network Management Agent (The "Local Representative"):
          \begin{itemize}
              \item What it is: A software process running inside the managed device.
              \item Its Role: It's the server's representative on the ground. It communicates with the managing server, receives commands, and takes local action on the device. It also gathers data from the device and sends it back to the server. This is analogous to the Control Agent (CA) in an SDN router.
          \end{itemize}
    \item Network Management Protocol (The "Language"):
          \begin{itemize}
              \item What it is: This is the protocol that runs between the managing server and the agent on the managed device.
              \item Its Role: It defines the syntax and semantics of the messages used by the server to query the device's status and control the device. It also allows the agent to inform the server of exceptional events (e.g., a link failure).
              \item Key Distinction: The protocol itself does not manage the network. It is just the tool that enables the manager to do so.
          \end{itemize}
    \item Textual Representation of Figure 5.20: Network Management Framework
          \begin{itemize}
              \item +-----------------------------------+
              \item |     Managing Server / Controller  |
              \item | (Manages data store, talks to     |
              \item |  human network managers)          |
              \item +-----------------------------------+
              \item        |           |           |
              \item        | (Network Management Protocol)
              \item        |           |           |
              \item +----------+ +----------+ +----------+
              \item |  Agent   | |  Agent   | |  Agent   |
              \item |----------| |----------| |----------|
              \item | Device   | | Device   | | Device   |
              \item | Data     | | Data     | | Data     |
              \item +----------+ +----------+ +----------+
              \item   Managed      Managed      Managed
              \item   Device         Device       Device
          \end{itemize}
    \item Three Approaches to Management in Practice
          \begin{itemize}
              \item CLI (Command Line Interface): The operator connects directly to the device (via console, Telnet, or SSH) and types vendor-specific commands (e.g., Cisco IOS).
              \item Pros: Powerful, direct control.
              \item Cons: Manual, error-prone, vendor-specific, difficult to automate, and does not scale to thousands of devices.
              \item SNMP/MIB (The "Classic" Protocol Approach):
              \item The operator uses the Simple Network Management Protocol (SNMP) to query or set standardized data objects (defined in a Management Information Base, or MIB) on a device.
              \item Primary Use: This is the workhorse for monitoring—querying operational data and device statistics.
              \item Limitation: It's less effective for configuration. It manages devices individually, and its "set" operations are often not robust enough for complex configurations.
              \item NETCONF/YANG (The "Modern" SDN-era Approach):
              \item This is a more holistic, network-wide approach that is "data-model-driven" and focuses on robust configuration management.
              \item YANG is a data-modeling language used to define all the configuration and operational data on a device in a clear, standardized way.
              \item NETCONF is a protocol that allows managers to manipulate these YANG data models, including performing atomic, multi-device transactions. This is the approach we saw in the ODL-controller's MD-SAL.
          \end{itemize}
    \item We will now examine the SNMP/MIB and NETCONF/YANG approaches in detail.
\end{enumerate}

\subsection{5.7.2 The Simple Network Management Protocol (SNMP) and the Management Information Base (MIB)}
\begin{enumerate}
    \item SNMPv3 is the current standard, defined in [RFC 3410].
    \item SNMP (The Protocol)
          \begin{itemize}
              \item Concept: SNMP is an application-layer protocol used to convey management information (control commands and data) between a managing server and an agent on a managed device.
              \item Operational Modes:
              \item Request-Response Mode: The managing server sends a request to an agent. The agent performs an action and sends a reply.
              \item Trap Mode: The agent sends an unsolicited trap message to the managing server.
              \item SNMP PDU Types (Table 5.2):
              \item GetRequest: Fetches the value of one or more MIB objects.
              \item GetNextRequest: Fetches the next MIB object.
              \item GetBulkRequest: Retrieves a large block of data.
              \item SetRequest: Sets the value of a MIB object.
              \item Response: The agent reply.
              \item SNMPv2-Trap: An unsolicited event message.
              \item Transport and Reliability:
              \item SNMP runs over UDP.
              \item Problem: UDP is unreliable.
              \item Solution: SNMP uses a Request ID so the manager can match responses. The manager must retransmit if necessary.
              \item Security:
              \item Early SNMP versions had weak security.
              \item SNMPv3 added authentication and encryption.
          \end{itemize}
    \item MIB (The Data)
          \begin{itemize}
              \item Concept: The MIB is the collection of managed objects representing device state.
              \item SMI: The data description language for MIB objects.
              \item MIB Modules: Groups of related MIB objects.
              \item Example MIB Object:
              \item ipSystemStatsInDelivers OBJECT-TYPE
              \item SYNTAX Counter32
              \item MAX-ACCESS read-only
              \item STATUS current
              \item DESCRIPTION "The total number of datagrams successfully delivered ..."
              \item ::= { ipSystemStatsEntry 18 }
              \item What this tells us: A 32-bit counter representing datagrams delivered to upper-layer protocols.
          \end{itemize}
\end{enumerate}

\subsection{5.7.3 The Network Configuration Protocol (NETCONF) and YANG}
\begin{enumerate}
    \item The SNMP/MIB/SMI framework was excellent for monitoring but too inflexible for configuration. The IETF created NETCONF and YANG.
    \item NETCONF (The Protocol)
          \begin{itemize}
              \item Concept: NETCONF [RFC 6241] is an application-layer protocol for managing device configurations.
              \item Mechanism:
              \item Transport: Uses RPC paradigm.
              \item Encoding: XML.
              \item Security: Runs over secure, connection-oriented sessions.
              \item NETCONF Session:
              \item Exchange <hello> messages.
              \item Server sends <rpc>.
              \item Device replies with <rpc-reply>.
              \item Device may send <notification>.
              \item Session ends with <close-session>.
              \item Key Operations (Table 5.3):
              \item <get-config>: Retrieve configuration.
              \item <get>: Retrieve configuration + operational state.
              \item <edit-config>: Transactional configuration.
              \item <lock> and <unlock>: Prevent conflicts.
              \item XML Message Example (set interface MTU):
              \item The full XML configuration message is included as given in the notes.
          \end{itemize}
    \item YANG (The Data Model)
          \begin{itemize}
              \item Concept: YANG [RFC 6020] defines data structure and semantics.
              \item Role: YANG specifies all configuration and operational data.
              \item Key Features:
              \item Structure: Defines full data hierarchy.
              \item Data Types: Small built-in set.
              \item Constraints: Enforces validity (e.g., MTU ranges, required dependencies).
          \end{itemize}
\end{enumerate}

\subsection{5.7.4 5.7 Section-Wide Summary}
\begin{enumerate}
    \item Key Terms and Definitions:
          \begin{itemize}
              \item Network Management: The activities used to deploy, monitor, configure, and control a network's resources.
              \item Managing Server: The centralized management application.
              \item Managed Device: A network component that is managed.
              \item Management Agent: The software process communicating with the server.
              \item SNMP: A UDP-based protocol for monitoring.
              \item MIB: The database of managed objects.
              \item SMI: The language defining MIB objects.
              \item NETCONF: A modern XML-based, RPC-style, secure protocol for configuration.
              \item YANG: The data-modeling language used by NETCONF.
          \end{itemize}
    \item Core Relationships:
          \begin{itemize}
              \item The Management Framework defines Manager, Device, Agent, Data, Protocol.
              \item SNMP uses SMI to define MIB objects.
              \item NETCONF uses YANG to define data models.
              \item Evolution: From device-by-device monitoring to full-network, model-driven configuration.
          \end{itemize}
    \item Key Insights / Takeaways:
          \begin{itemize}
              \item Network Management is crucial and much broader than routing.
              \item SNMP's simplicity was both strength and weakness.
              \item NETCONF/YANG align with SDN, treating configuration as a programmable, model-driven system.
              \item NETCONF's <lock> and transactional <edit-config> prevent conflicting changes.
              \item YANG constraints move correctness into the data model.
          \end{itemize}
\end{enumerate}


% TEMPLATE
\begin{enumerate}
    \item X
          \begin{enumerate}
              \item Y
          \end{enumerate}
\end{enumerate}





\end{document}